from io import BytesIO
from scrapli.decorators import TimeoutOpsModifier as TimeoutOpsModifier
from scrapli.driver import AsyncDriver as AsyncDriver
from scrapli.driver.generic.base_driver import BaseGenericDriver as BaseGenericDriver
from scrapli.exceptions import ScrapliValueError as ScrapliValueError
from scrapli.response import MultiResponse as MultiResponse, Response as Response
from typing import Any, Callable, Dict, List, Optional, Tuple, Union

class AsyncGenericDriver(AsyncDriver, BaseGenericDriver):
    def __init__(self, host: str, port: int=..., auth_username: str=..., auth_password: str=..., auth_private_key: str=..., auth_private_key_passphrase: str=..., auth_strict_key: bool=..., auth_bypass: bool=..., timeout_socket: float=..., timeout_transport: float=..., timeout_ops: float=..., comms_prompt_pattern: str=..., comms_return_char: str=..., comms_ansi: bool=..., ssh_config_file: Union[str, bool]=..., ssh_known_hosts_file: Union[str, bool]=..., on_init: Optional[Callable[..., Any]]=..., on_open: Optional[Callable[..., Any]]=..., on_close: Optional[Callable[..., Any]]=..., transport: str=..., transport_options: Optional[Dict[str, Any]]=..., channel_log: Union[str, bool, BytesIO]=..., channel_lock: bool=..., logging_uid: str=...) -> None: ...
    async def get_prompt(self) -> str: ...
    async def _send_command(self, command: str, strip_prompt: bool=..., failed_when_contains: Optional[Union[str, List[str]]]=..., eager: bool=..., timeout_ops: Optional[float]=...) -> Response: ...
    async def send_command(self, command: str, *, strip_prompt: bool=..., failed_when_contains: Optional[Union[str, List[str]]]=..., timeout_ops: Optional[float]=...) -> Response: ...
    async def send_commands(self, commands: List[str], *, strip_prompt: bool=..., failed_when_contains: Optional[Union[str, List[str]]]=..., stop_on_failed: bool=..., eager: bool=..., timeout_ops: Optional[float]=...) -> MultiResponse: ...
    async def send_commands_from_file(self, file: str, *, strip_prompt: bool=..., failed_when_contains: Optional[Union[str, List[str]]]=..., stop_on_failed: bool=..., eager: bool=..., timeout_ops: Optional[float]=...) -> MultiResponse: ...
    async def send_and_read(self, channel_input: str, *, expected_outputs: Optional[List[str]]=..., strip_prompt: bool=..., failed_when_contains: Optional[Union[str, List[str]]]=..., timeout_ops: Optional[float]=..., read_duration: float=...) -> Response: ...
    async def send_interactive(self, interact_events: List[Tuple[str, str, Optional[bool]]], *, failed_when_contains: Optional[Union[str, List[str]]]=..., privilege_level: str=..., timeout_ops: Optional[float]=...) -> Response: ...
